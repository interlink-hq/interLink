---
title: TLS/mTLS Configuration
sidebar_label: TLS/mTLS Setup
---

# TLS/mTLS Configuration for interLink

This guide explains how to configure TLS encryption and mutual TLS (mTLS) authentication between the Virtual Kubelet and interLink API server for secure communication.

## Overview

interLink supports two levels of security for HTTP communication:

- **TLS (Transport Layer Security)**: Encrypts communication between Virtual Kubelet and interLink API server
- **mTLS (Mutual TLS)**: Provides bidirectional authentication where both client and server verify each other's certificates

## Prerequisites

Before configuring TLS/mTLS, you need:

1. A Certificate Authority (CA) certificate
2. Server certificate and private key for the interLink API server
3. Client certificate and private key for the Virtual Kubelet (for mTLS only)

### Generating Certificates

Here's an example of generating certificates using OpenSSL:

```bash
# Generate CA private key
openssl genrsa -out ca-key.pem 4096

# Generate CA certificate
openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem -subj "/C=US/ST=CA/L=San Francisco/O=InterLink/CN=InterLink CA"

# Generate server private key
openssl genrsa -out server-key.pem 4096

# Generate server certificate signing request
openssl req -subj "/C=US/ST=CA/L=San Francisco/O=InterLink/CN=interlink-server" -sha256 -new -key server-key.pem -out server.csr

# Generate server certificate signed by CA
openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem -out server-cert.pem -extensions v3_req

# Generate client private key (for mTLS)
openssl genrsa -out client-key.pem 4096

# Generate client certificate signing request
openssl req -subj "/C=US/ST=CA/L=San Francisco/O=InterLink/CN=interlink-client" -sha256 -new -key client-key.pem -out client.csr

# Generate client certificate signed by CA
openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem -out client-cert.pem -extensions v3_req

# Clean up CSR files
rm server.csr client.csr
```

## Configuration

### interLink API Server Configuration

Configure the interLink API server to enable TLS/mTLS by updating your `InterLinkConfig.yaml`:

#### TLS Only (Server Authentication)

```yaml
InterlinkAddress: https://0.0.0.0
InterlinkPort: "3000"
SidecarURL: http://plugin
SidecarPort: "4000"
VerboseLogging: true
ErrorsOnlyLogging: false
DataRootFolder: "/tmp/interlink"

# TLS Configuration
TLS:
  Enabled: true
  CertFile: "/etc/interlink/certs/server-cert.pem"
  KeyFile: "/etc/interlink/certs/server-key.pem"
  # CACertFile is optional for TLS-only mode
```

#### mTLS (Mutual Authentication)

```yaml
InterlinkAddress: https://0.0.0.0
InterlinkPort: "3000"
SidecarURL: http://plugin
SidecarPort: "4000"
VerboseLogging: true
ErrorsOnlyLogging: false
DataRootFolder: "/tmp/interlink"

# mTLS Configuration
TLS:
  Enabled: true
  CertFile: "/etc/interlink/certs/server-cert.pem"
  KeyFile: "/etc/interlink/certs/server-key.pem"
  CACertFile: "/etc/interlink/certs/ca.pem"  # Enables client certificate verification
```

### Virtual Kubelet Configuration

Configure the Virtual Kubelet to connect using TLS/mTLS by updating your Virtual Kubelet configuration:

#### TLS Only (Server Authentication)

```yaml
InterlinkURL: https://interlink-server
InterlinkPort: "3000"
VerboseLogging: true
ErrorsOnlyLogging: false

# TLS Configuration for client
TLS:
  Enabled: true
  CACertFile: "/etc/vk/certs/ca.pem"  # CA cert to verify server
  # CertFile and KeyFile are optional for TLS-only mode
```

#### mTLS (Mutual Authentication)

```yaml
InterlinkURL: https://interlink-server
InterlinkPort: "3000"
VerboseLogging: true
ErrorsOnlyLogging: false

# mTLS Configuration for client
TLS:
  Enabled: true
  CertFile: "/etc/vk/certs/client-cert.pem"    # Client certificate
  KeyFile: "/etc/vk/certs/client-key.pem"      # Client private key
  CACertFile: "/etc/vk/certs/ca.pem"           # CA cert to verify server
```

## Deployment Examples

### Docker Compose

```yaml
version: '3.8'
services:
  interlink:
    image: ghcr.io/interlink-hq/interlink/interlink:latest
    ports:
      - "3000:3000"
    volumes:
      - ./interlink-config.yaml:/etc/interlink/InterLinkConfig.yaml
      - ./certs:/etc/interlink/certs:ro
    environment:
      - INTERLINKCONFIGPATH=/etc/interlink/InterLinkConfig.yaml

  virtual-kubelet:
    image: ghcr.io/interlink-hq/interlink/virtual-kubelet:latest
    volumes:
      - ./vk-config.yaml:/etc/vk/config.yaml
      - ./certs:/etc/vk/certs:ro
      - ~/.kube/config:/root/.kube/config:ro
    depends_on:
      - interlink
```

### Kubernetes Deployment

#### interLink API Server with mTLS

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: interlink-server
  namespace: interlink
spec:
  replicas: 1
  selector:
    matchLabels:
      app: interlink-server
  template:
    metadata:
      labels:
        app: interlink-server
    spec:
      containers:
      - name: interlink
        image: ghcr.io/interlink-hq/interlink/interlink:latest
        ports:
        - containerPort: 3000
        env:
        - name: INTERLINKCONFIGPATH
          value: "/etc/interlink/InterLinkConfig.yaml"
        volumeMounts:
        - name: config
          mountPath: /etc/interlink/InterLinkConfig.yaml
          subPath: InterLinkConfig.yaml
        - name: tls-certs
          mountPath: /etc/interlink/certs
          readOnly: true
      volumes:
      - name: config
        configMap:
          name: interlink-config
      - name: tls-certs
        secret:
          secretName: interlink-tls-certs
---
apiVersion: v1
kind: Service
metadata:
  name: interlink-service
  namespace: interlink
spec:
  selector:
    app: interlink-server
  ports:
  - port: 3000
    targetPort: 3000
    protocol: TCP
  type: ClusterIP
```

#### Secrets for Certificates

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: interlink-tls-certs
  namespace: interlink
type: Opaque
data:
  ca.pem: LS0tLS1CRUdJTi... # base64 encoded CA certificate
  server-cert.pem: LS0tLS1CRUdJTi... # base64 encoded server certificate
  server-key.pem: LS0tLS1CRUdJTi... # base64 encoded server private key
---
apiVersion: v1
kind: Secret
metadata:
  name: vk-tls-certs
  namespace: interlink
type: Opaque
data:
  ca.pem: LS0tLS1CRUdJTi... # base64 encoded CA certificate
  client-cert.pem: LS0tLS1CRUdJTi... # base64 encoded client certificate
  client-key.pem: LS0tLS1CRUdJTi... # base64 encoded client private key
```

## Security Considerations

### Certificate Management

1. **Certificate Rotation**: Implement regular certificate rotation for production deployments
2. **Private Key Security**: Store private keys securely and limit access permissions
3. **CA Protection**: Keep the CA private key highly secure and consider using a proper PKI solution for production

### Network Security

1. **Network Isolation**: Deploy interLink components in isolated network segments when possible
2. **Firewall Rules**: Configure appropriate firewall rules to restrict access to interLink ports
3. **Monitoring**: Implement monitoring for certificate expiration and TLS handshake failures

### Configuration Validation

1. **Certificate Validation**: Ensure certificates contain appropriate Subject Alternative Names (SANs) for your deployment
2. **Cipher Suites**: The implementation uses TLS 1.2+ with secure cipher suites by default
3. **Testing**: Test your TLS/mTLS configuration in a development environment before production deployment

## Troubleshooting

### Common Issues

#### Certificate Verification Errors

```bash
# Check certificate details
openssl x509 -in server-cert.pem -text -noout

# Verify certificate chain
openssl verify -CAfile ca.pem server-cert.pem

# Test TLS connection
openssl s_client -connect interlink-server:3000 -CAfile ca.pem
```

#### mTLS Handshake Failures

1. **Check client certificate**: Ensure the client certificate is signed by the same CA
2. **Verify certificate paths**: Confirm file paths in configuration are correct
3. **Check permissions**: Ensure certificate files are readable by the application

#### Log Analysis

Enable verbose logging to troubleshoot TLS issues:

```yaml
VerboseLogging: true
```

Look for log messages containing:
- "Loaded CA certificate for TLS client"
- "Loaded client certificate for mTLS"
- "mTLS enabled - requiring client certificates"
- "Failed to create TLS HTTP client"

## Performance Considerations

1. **Certificate Caching**: Certificates are loaded once during startup for optimal performance
2. **Connection Pooling**: TLS connections benefit from HTTP connection pooling
3. **CPU Usage**: TLS/mTLS adds computational overhead; monitor CPU usage in high-throughput scenarios

## Migration from HTTP to HTTPS

To migrate existing deployments from HTTP to HTTPS:

1. **Generate certificates** as described above
2. **Update interLink configuration** to use `https://` URL and add TLS configuration
3. **Update Virtual Kubelet configuration** to use `https://` URL and add TLS configuration
4. **Deploy updated configurations** ensuring certificate files are available
5. **Verify connectivity** before removing HTTP endpoints

## Integration with Certificate Management

For production deployments, consider integrating with:

- **cert-manager** for Kubernetes certificate management
- **HashiCorp Vault** for secret management
- **AWS Certificate Manager** for cloud deployments
- **Let's Encrypt** for public certificate authorities